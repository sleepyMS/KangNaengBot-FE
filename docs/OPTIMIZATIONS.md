[← 메인으로 돌아가기](../README.md)

# 최적화 및 성능 개선 (Optimizations)

애플리케이션의 성능과 사용자 경험(UX)을 향상시키기 위해 적용한 기술적 최적화 사항들입니다.

## 1. API-First 개발을 통한 병렬 작업

백엔드 개발 대기 없이 프론트엔드 개발을 진행하기 위한 전략을 적용했습니다.

- **API 명세서 선행 작성**: 프론트엔드 관점에서 필요한 API 구조를 [`SCHEDULE_API_SPEC.md`](./SCHEDULE_API_SPEC.md)로 상세히 문서화했습니다.
- **Mock 서비스 구현**: 명세서 기반으로 `scheduleService`에 Mock 응답을 구현하여 실제 API 없이도 전체 기능을 개발/테스트했습니다.
- **계약 기반 통합**: API 명세서가 "계약서" 역할을 하여 백엔드 구현 완료 시 최소한의 수정으로 통합 가능했습니다.
- **결과**: 프론트엔드와 백엔드가 **병렬 개발**, 통합 시 충돌 최소화

## 2. 클라이언트 사이드 시간표 필터링

시간표 필터 변경 시마다 API를 호출하면 네트워크 지연으로 UX가 저하됩니다. 이를 해결하기 위해 **완전한 클라이언트 사이드 필터링**을 구현했습니다.

- **원본 데이터 분리**: `allSchedules`(원본)와 `generatedSchedules`(필터링 결과)를 분리하여 관리합니다.
- **즉시 필터 적용**: 필터 변경 시 `applyFilters()` 함수가 로컬 메모리에서 즉시 필터링을 수행합니다.
  - **공강 요일 필터**: 선택된 요일에 수업이 있는 시간표 제외
  - **제외 시간대 필터**: `globalExcludedSlots` Set과 겹치는 시간대가 있는 시간표 제외
- **결과**: 필터 적용 즉시(0ms 지연) UI 업데이트, **네트워크 요청 0건**

## 3. 동적 시간표 그리드 렌더링

주간/야간 학생 모두에게 최적화된 시간표 뷰를 제공합니다.

- **동적 범위 계산**: 과목들의 `startTime`/`endTime`을 분석하여 최소~최대 시간 범위 산출
- **조건부 그리드 확장**: 야간 수업(18:00 이후)이 있는 경우에만 22시까지 그리드 확장
- **CSS Grid 최적화**: `minmax()`를 활용하여 시간대 수에 따라 셀 높이 자동 조절
- **결과**: 주간 학생에게는 컴팩트한 뷰, 야간 학생에게는 확장 뷰 → **화면 활용도 극대화**

## 4. 시간표 생성 낙관적 UI (Optimistic UI)

시간표 생성 API 응답 대기 시간 동안 화면이 멈춰 보이는 문제를 해결했습니다.

- **즉시 메시지 표시**: 사용자 입력 즉시 `addMessage`로 채팅에 메시지 추가
- **선제적 화면 전환**: 세션 생성 완료 전에 대화방으로 `navigate` 실행
- **생성 중 상태 표시**: "최적의 조합을 분석하고 있어요..." 메시지와 로딩 인디케이터 표시
- **메시지 보존**: `createSession` 호출 시 `keepMessages` 옵션으로 기존 낙관적 메시지 유지
- **결과**: 체감 반응 속도 **1초 이상 단축** (사용자 입력 → 화면 전환 즉시)

## 5. 지능형 데이터 프리페칭 (Intelligent Data Prefetching)

채팅 세션 간 이동 시 로딩 시간을 최소화하기 위해 고도화된 프리페칭 전략을 구현했습니다.

- **호버 프리페칭 (Hover Prefetching)**:
  - 사이드바의 세션 목록에 마우스를 올리는 순간(`onMouseEnter`), 해당 세션의 메시지 데이터를 백그라운드에서 미리 요청합니다.
- **중복 요청 방지 (Request Deduplication)**:
  - `Map` 자료구조를 활용한 `pendingPrefetches` 캐시를 도입했습니다.
  - 이미 로딩 중인 세션에 대해 중복된 API 호출이 발생하지 않도록, 진행 중인 `Promise`를 재사용하여 네트워크 리소스를 절약했습니다.
  - 사용자가 빠르게 마우스를 움직일 때 발생할 수 있는 'Race Condition'을 효과적으로 방지했습니다.

## 6. 클라이언트 사이드 캐싱 (Client-Side Caching)

서버 부하를 줄이고 체감이 빠른 UI를 제공하기 위해 메모리 캐싱을 도입했습니다.

- **메시지 캐시 (`messageCache`)**:
  - `useChatStore` 내부에 `Map<string, MessageItem[]>` 형태의 캐시를 두어, 한 번 불러온 세션의 대화 내용은 메모리에 저장합니다.
  - 사용자가 이전에 방문한 세션을 다시 클릭할 경우, 네트워크 요청 없이 캐시된 데이터를 즉시 렌더링하고, 백그라운드에서 조용히 최신 데이터를 동기화합니다.

## 7. 낙관적 UI (Optimistic UI)

네트워크 응답 속도와 관계없이 즉각적인 반응성을 제공합니다.

- **즉시 렌더링**: 메시지 전송 버튼을 누르는 즉시 로컬 상태를 업데이트하여 화면에 말풍선을 표시합니다.
- **백그라운드 처리**: 실제 API 요청은 백그라운드에서 처리되며, 성공 시 상태를 유지하고 실패 시에만 롤백 처리하여 사용자 흐름을 방해하지 않습니다.

## 8. 시간표 이미지 다운로드 최적화

`html-to-image` 라이브러리를 사용하여 시간표를 PNG로 저장하는 기능에서 UX를 최적화했습니다.

- **고해상도 설정**: `pixelRatio: 2`로 선명한 이미지 품질 확보 (Retina 디스플레이 대응)
- **로딩 피드백**: 다운로드 버튼에 `isDownloading` 상태 기반 스피너 표시
- **다크모드 자동 감지**: `document.documentElement.classList.contains("dark")` 체크 후 배경색 자동 설정 (`#0f172a` vs `#ffffff`)
- **토스트 알림**: 성공/실패 시 사용자에게 명확한 피드백 제공

## 9. 번들 크기 및 리소스 최적화

- **Vite 기반 빌드**: ES Modules 기반의 Vite를 사용하여 개발 서버 구동 속도와 HMR(Hot Module Replacement) 속도를 극대화했습니다.
- **Tailwind CSS JIT**: 사용되는 클래스만 CSS로 컴파일되는 JIT(Just-In-Time) 모드를 통해 CSS 파일 크기를 최소화했습니다.
