[← 메인으로 돌아가기](../README.md)

# 개발 중 직면한 어려움과 해결 과정 (Challenges & Solutions)

프로젝트 개발 과정에서 마주친 기술적 난관들과 이를 극복하기 위해 적용한 해결책들을 정리했습니다.

## 1. 기획 부재 상황에서의 빠른 MVP 개발 (Agile & API-First)

**문제점 (Challenge):**
시간표 생성 기능은 기획이 완전히 정해지지 않은 상태에서 개발을 시작해야 했습니다. 백엔드 개발자와의 소통 지연, 요구사항의 빈번한 변경으로 인해 전통적인 폭포수 방식으로는 개발 일정을 맞추기 어려웠습니다.

**해결책 (Solution):**

- **프론트엔드 우선 개발 (Frontend-First)**: 가설 단위로 기능을 빠르게 프로토타이핑하고, Mock 데이터로 UI/UX를 선 검증하는 방식을 채택했습니다.
- **API 명세서 선행 작성**: 백엔드 구현 전에 프론트엔드 관점에서 [`SCHEDULE_API_SPEC.md`](./SCHEDULE_API_SPEC.md)를 상세히 작성하여 백엔드 개발자에게 전달했습니다. 이를 통해 양측이 동시에 개발을 진행할 수 있었습니다.
- **결과**: 애자일 방법론을 따라 짧은 스프린트 주기로 피드백을 반영하며, 하루 만에 핵심 MVP 기능을 완성했습니다. API 명세서가 "계약서" 역할을 하여 통합 시 충돌을 최소화했습니다.

## 2. 다양한 사용자 시간대 대응 (동적 시간표 그리드)

**문제점 (Challenge):**
대학 강의는 주간 수업(보통 09:00~18:00)과 야간 수업(18:00~22:00)으로 나뉩니다. 모든 사용자에게 22시까지의 전체 그리드를 보여주면 주간 학생에게는 불필요한 공간 낭비이고, 반대로 야간 학생에게 18시까지만 보여주면 수업이 잘리는 문제가 있었습니다.

**해결책 (Solution):**

- **동적 시간 범위 계산**: 시간표에 포함된 과목들의 `startTime`/`endTime`을 분석하여, 가장 이른 시작 시간과 가장 늦은 종료 시간을 동적으로 계산합니다.
- **그리드 자동 조절**: 주간 수업만 있는 학생에게는 09:00~18:00 범위의 컴팩트한 그리드를, 야간 수업이 포함된 학생에게는 09:00~22:00 확장 그리드를 자동으로 렌더링합니다.
- **반응형 셀 높이**: CSS Grid의 `auto-fit`과 `minmax()`를 활용하여 시간대 수에 따라 셀 크기가 적절히 조절되도록 구현했습니다.
- **결과**: 모든 사용자에게 최적화된 시간표 뷰를 제공하여 화면 활용도와 가독성을 크게 향상시켰습니다.

## 3. 시간표 충돌 시각화 및 분 단위 처리

**문제점 (Challenge):**
기존 "1~9교시" 기반의 시스템은 06:30~07:45 같은 반 교시 수업이나 비정형 시간대를 표현할 수 없었습니다. 또한 2개 이상의 과목이 같은 시간대에 겹치는 충돌 상황을 어떻게 시각화할지 고민이 필요했습니다.

**해결책 (Solution):**

- **분 단위 시간 형식 도입**: `TimeSlot` 타입을 `{ start: "HH:MM", end: "HH:MM" }` 형태로 정의하여 어떤 시간대든 표현 가능하게 했습니다.
- **CSS Grid 동적 계산**: 그리드 렌더링 시 `gridRowStart`/`gridRowEnd`를 분 단위로 계산하여 정확한 위치에 과목 타일을 배치합니다.
- **충돌 시각화**: 같은 셀에 여러 과목이 겹칠 경우, `flex` 레이아웃으로 타일을 나란히 배치하고 각 과목의 상대적 너비를 조절하여 충돌 상황을 명확히 보여줍니다.

## 4. 비동기 데이터와 UI 동기화 문제 (Chat UX)

**문제점 (Challenge):**
사용자가 메시지를 보낸 후, 서버로부터 AI의 응답이 올 때까지의 지연 시간(Latency) 동안 화면이 정지된 것처럼 보이는 문제가 있었습니다. 또한, 네트워크 상태가 불안정할 때 요청이 실패하면 사용자는 메시지가 보내졌는지 알 수 없어 혼란스러워했습니다.

**해결책 (Solution):**

- **낙관적 업데이트 (Optimistic Update)** 적용: 서버 응답을 기다리지 않고, `sendMessage` 호출 즉시 로컬 상태(`messages`)에 사용자의 메시지를 추가하여 UI 반응성을 높였습니다.
- **상태 롤백**: `try-catch` 블록을 활용하여 API 호출 실패 시, 임시로 추가했던 메시지를 `slice`로 제거하고 에러 메시지를 표시하여 데이터 무결성을 유지했습니다.
- **재시도 메커니즘**: 단순 실패 처리가 아닌, 백그라운드 재시도(Retry) 로직을 `useChatStore`에 구현하여 일시적인 네트워크 오류를 사용자가 인지하지 못하게 자동으로 복구했습니다.

## 5. 복잡한 계층형 폼 데이터 관리

**문제점 (Challenge):**
프로필 수정 페이지에서 '단과대학 → 학부 → 전공'으로 이어지는 계층적 데이터 구조를 처리해야 했습니다. 상위 항목(예: 단과대학)이 변경되었을 때 하위 항목(예: 학부, 전공)이 초기화되지 않거나, 잘못된 조합이 선택된 채로 남는 버그가 발생하기 쉬웠습니다.

**해결책 (Solution):**

- **의존성 기반 상태 초기화**: `handleChange` 함수 내에서 특정 필드 변경 시 연관된 하위 필드들을 명시적으로 빈 문자열(`""`)로 초기화하는 로직을 통합했습니다.
- **동적 옵션 필터링**: `DEPARTMENTS`, `MAJORS` 상수 객체를 활용하여, 현재 선택된 상위 키값에 따라 하위 드롭다운의 `options`를 실시간으로 계산하여 렌더링하도록 구현했습니다.

## 6. 다크 모드 깜빡임 (FOUC)

**문제점 (Challenge):**
페이지 새로고침 시, 자바스크립트가 로드되고 테마 상태(`zustand`)를 읽어오기 전까지 아주 짧은 순간 흰색(기본) 배경이 보였다가 다크 모드로 변하는 '깜빡임(Flash of Unstyled Content)' 현상이 발생했습니다.

**해결책 (Solution):**

- **로컬 스토리지 동기화**: `zustand`의 `persist` 미들웨어를 사용하여 테마 설정을 `localStorage`에 저장했습니다.
- **초기화 로직 최적화**: 앱 진입 시점(`App.tsx`의 `useEffect`) 뿐만 아니라, `initializeTheme` 함수를 통해 스토어 초기화 시점에 즉시 `document.documentElement`에 `dark` 클래스를 주입하여 렌더링 이전에 테마가 적용되도록 했습니다.

## 7. 인증 토큰 만료 처리

**문제점 (Challenge):**
`access_token`이 만료되었을 때, 사용자가 이를 인지하지 못하고 계속 API 요청을 보내면 401 에러가 발생하고 앱이 동작하지 않는 것처럼 보이는 문제가 있었습니다.

**해결책 (Solution):**

- **Axios Interceptor 중앙화**: 개별 컴포넌트에서 에러를 처리하는 대신, `apiClient`의 응답 인터셉터에서 401 에러를 전역적으로 감지하도록 구현했습니다.
- **자동 로그아웃 흐름**: 401 발생 시 즉시 로컬 스토리지의 토큰을 삭제하고 `/login`으로 강제 이동시켜, 사용자가 자연스럽게 재로그인할 수 있는 흐름(Flow)을 만들었습니다.
